package com.ahmed.tictactoe;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

//AI adapted from https://tutorialedge.net/artificial-intelligence/min-max-algorithm-in-java/
public class AI {

    //char[] newBoard = arr; //Board array containing default pieces (empty)

    char human = 'X'; //By default, player is X (Change later to have flag based on user input
    char cpu = 'O';
    List<Move> availableMoves;
    Move aiMove;
    char[] board = MainActivity.arr;

    List<Move> getEmptySpaces() //Method for finding empty indices
    {
        availableMoves = new ArrayList<>();
        for (int i = 0; i < board.length; i++) //Iterate through all elements of board (9)
        {
            if (board[i] != 'X' && board[i]!= 'O') {
                availableMoves.add(new Move(i));
            }
        }

        return availableMoves;
    }

    boolean win(char[] board, char player) {
        if (board[0] == board[1] && board[1] == board[2] && board[1] == player) //First row all the same (and not empty)
        {
            return true;
        } else if (board[3] == board[4] && board[4] == board[5] && board[4] == player) //Second row all the same
        {
            return true;
        } else if (board[6] == board[7] && board[7] == board[8] && board[7] == player) //Third row all the same
        {
            return true;
        } else if (board[0] == board[3] && board[3] == board[6] && board[3] == player) //First column all the same
        {
            return true;
        } else if (board[1] == board[4] && board[4] == board[7] && board[4] == player) //Second column all the same
        {
            return true;
        } else if (board[2] == board[5] && board[5] == board[8] && board[5] == player) //Third column all the same
        {
            return true;
        } else if (board[0] == board[4] && board[4] == board[8] && board[4] == player) //Diagonal top left to bottom right the same
        {
            return true;
        } else if (board[2] == board[4] && board[4] == board[6] && board[4] == player) //Diagonal bottom left to top right the same
        {
            return true;
        }


        return false;
    }

    void makeMove(Move move, char player)
    {
        board[move.index] = player;
    }

    Move getRandomMove(char[] board)
    {
        Move random;
        Random r = new Random();
        List<Move> movesAvailable = getEmptySpaces();
        random = movesAvailable.get(r.nextInt(movesAvailable.size()));
        return random;
    }

    int minimax(int depth, int turn) {

        if (win(board, human)) //If the human wins, return negative score
        {
            return -1;
        }
        if (win(board, cpu)) //If the AI wins, return positive score
        {
            return 1;
        }

        List<Move> movesAvailable = getEmptySpaces(); //Get all the empty spots

        if (movesAvailable.isEmpty()) //If there are no empty spaces, return 0 (draw)
        {
            return 0;
        }

        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE; //Set min and max values

        for (int i = 0; i < movesAvailable.size(); i++) { //Iterate through each move available
            //create an object for each and store the index of that spot
            Move move = movesAvailable.get(i);
            if (turn == 1) //If it is the AI turn
            {
                makeMove(move,cpu); //Makes a move on the board (O piece)
                int currentScore = minimax(depth + 1, 2); //Recursively checks next move (players turn then computers turn)
                max = Math.max(currentScore, max);
                if(currentScore >= 0) //If its a good move, set aiMove to that move
                {
                    if(depth == 0)
                    {
                        aiMove = move;
                    }
                }
                if(currentScore == 1)
                {
                    board[move.index] = 0;
                    break;
                }
                if(i == movesAvailable.size()-1 && max < 0)
                {
                    if(depth == 0)
                    {
                        aiMove = move;
                    }
                }
            }
            else if (turn == 2) {
                makeMove(move, human);
                int currentScore = minimax(depth + 1, 1);
                min = Math.min(currentScore, min);
                if(min == -1)
                {
                    board[move.index] = 0;
                    break;
                }
            }
           board[move.index] = 0; //Reset this point
        }

            return turn==1?max:min; //If it is the AI turn, return max, otherwise return min
        }

     Move getBestMove() //Method for returning the best move generated by minimax algorithm
     {
         Move bestMove = new Move(1); //Initialize a move
         bestMove.score = minimax(0,1);
         bestMove = aiMove;

         return bestMove;
     }



}